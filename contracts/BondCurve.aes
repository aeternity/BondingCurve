@compiler >=4.2

include "Frac.aes"

contract BondCurve =

 // token : TokenContract
  record state = { init_buy_price : Frac.frac
                 , init_sell_price : Frac.frac
                 , alpha: Frac.frac }

  stateful entrypoint init() =
    // { total_supply = 0, init_buy_price = 1, init_sell_price = 0, alpha = 1 }
    { init_buy_price = Frac.from_int(1), init_sell_price = Frac.from_int(0), alpha = Frac.from_int(1) }
    
  // Returns the current buy price
  entrypoint buy_price(total_supply: Frac.frac) : Frac.frac =
    buy_curve(total_supply)
  
  // Returns the current sell price
  entrypoint sell_price(total_supply: Frac.frac) : Frac.frac =
    sell_curve(total_supply)
  
  // Returns the amount of fungible tokens to be received
  // when buying from the curve for the passed value of AE tokens.
  // entrypoint calculate_buy_return(amount: Frac.frac) : Frac.frac = 0
    // delta = b^2 + 2a*((a * c^2/2 + b * c) + AE)
    // n = (-b + sqrt(delta)) / a
    // Requires SQRT and approximation which is impossible rn

  entrypoint buy_tokens_price(total_supply: Frac.frac, buy_tokens: Frac.frac) : Frac.frac =
    // (buy_price() + buy_curve(total_supply + buy_tokens)) * buy_tokens / Frac.from_int(2)
    Frac.div(Frac.mul((Frac.add(buy_price(total_supply), buy_curve(Frac.add(total_supply, buy_tokens)))), buy_tokens), Frac.from_int(2))

  // Returns the amount of AE tokens to be received
  // when selling fungible tokens back to the curve.
  entrypoint calculate_sell_return(total_supply: Frac.frac, sell_tokens: Frac.frac) : Frac.frac =
    // (sell_price() + sell_curve(total_supply - sell_tokens)) * sell_tokens / Frac.from_int(2)
    Frac.div(
      Frac.mul(
        (Frac.add(sell_price(total_supply), sell_curve(Frac.sub(total_supply, sell_tokens)))), sell_tokens),
      Frac.from_int(2))

  // Buy curve formula
  entrypoint buy_curve(x: Frac.frac) : Frac.frac = Frac.add(Frac.mul(x, state.alpha), state.init_buy_price)

  // Sell curve formula
  entrypoint sell_curve(x: Frac.frac) : Frac.frac = Frac.sub(Frac.mul(x, state.alpha), state.init_sell_price)


  // !!! IMPORTANT
  // require(Frac.is_sane(), "EVERYWHERE WHEN THE");
// 